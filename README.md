# `rules_python` Pip name examples

Exploration of ways to retrieve PyPI metadata from repos generated by the
`pip.parse` module extension from [bazel-contrib/rules_python][rules_python].

Inspired by [a question in the #bzlmod channel of the Bazel Slack workspace from
Frank P on 2025-04-01][slack].

## Background

Frank P had the need to find the PyPI package to which a dependency's source
file belongs, to generate a `requirements` list for [py_wheel][]. He'd
previously used something like the following, which depends upon the [canonical
repo name][] of the repo generated via the `pip.parse` module extension tag:

```py
PIP_REPO_PREFIX = "rules_python++pip+<hub_name>_311_"

owner_name = file.owner.repo_name

if owner_name.startswith(PIP_REPO_PREFIX):
    pypi_name = owner_name.removeprefix(PIP_REPO_PREFIX)
```

He'd noted the following quote from [Module extensions: Repository names and
visibility][] (emphasis mine):

> Repos generated by extensions have canonical names in the form of
> `module_repo_canonical_name+extension_name+repo_name`. Note that
> __the canonical name format is not an API you should depend on â€”
> it's subject to change at any time.__

My stopgap suggestion was to search for the `"<hub_name>_311_"` marker instead
of the entire repo prefix:

```py
PIP_REPO_MARKER = "<hub_name>_311_"

owner_name = file.owner.repo_name

if PIP_REPO_MARKER in owner_name:
    _unused_prefix, pypi_name = owner_name.split(PIP_REPO_MARKER)
```

It may be less fragile than depending on the whole canonical repo name, but it's
not wonderful. I've been obsessed with canonical repo name issues, as evidenced
by my [EngFlow blog series on Bzlmod][blog], so I wanted to find another way.

I discovered the `pypi_name` and `pypi_version` tags that [whl_library][] adds
to [py_library][] targets for PyPI packages. bazel-contrib/rules_python#530
first introduced these tags to "[allow] tooling to use a bazel query to
reverse-engineer a requirements.txt from a transitive closure of a py_binary."

These seem like just the right source of truth for extracting the original PyPI
package names and versions. However, even though [the 'tags' attribute is common
to all rules][tags], there is no standard API to collect them from a [Target][].
They are not included in any [standard Bazel providers][].

## Experiments

The first two experiments use [Bazel's query language][] to find rules matching
the `pypi_name=.*` tag. These produce files that would have to be generated and
parsed somewhere in the build graph.

The last experiment adds a new [provider][] to `rules_python` to collect PyPI
names and versions directly from `py_library` targets.

### [query.sh][]

This script uses `bazel query` and [jq][] to filter the PyPI names from all the
targets in the repo. It's more an initial proof of concept than a practical
solution.

### `//:names.json`

`pip_names_query` from [pip_tags.bzl][] instantiates a [genquery][] to perform a
query similar to [query.sh][], but scoped to a specific target. It emits a full
JSON file, since [jq][] isn't included in any toolchains.

Such a target could perhaps be generated by a [repository_rule][], which another
repository rule could depend upon. This latter repository rule could use
[repository_ctx.read][] and the [json][] module to parse the result and generate
a BUILD target from it. This target could then return a [provider][] exposing the
PyPI name mapping.

### `//:names`

`pip_names` from [pip_tags.bzl][] depends on the `PypiInfo` [provider][] from
[rules_python_pypi_info.patch][]. The [single_version_override][] in
[MODULE.bazel][] applies this patch to `rules_python`.

This implementation is arguably the most powerful and most correct way of
retrieving the name of a PyPI module. From the `PypiInfo` docstring:

> PyPI metadata for py_library targets and their dependencies.
>
> `pip.parse` generates repositories that contain `py_library` targets for
> external PyPI dependencies. These `py_library` targets contain `pypy_name=...`
> and `pypy_version=...` tags, which become the `name` and `version` properties
> of this provider.
>
> Direct and transitive dependencies of the current target that contain
> `PypiInfo` become members of this target's `PypiInfo.pypy_deps` depset.

## History of the `pypi_*` tags

I used [gitk][] in a local clone of [rules_python][] to search for a commit with
`changing lines matching:` set to `pypi_name=`. I ran `gitk` on one file at a
time, not the entire repo, to make it easier to read the diff. Because of this,
I had to rerun `gitk` as the line moved from file to file:

```txt
# This the file that currently sets the `pypi_*` tags.
gitk python/private/pypi/whl_library.bzl

# Moved from here in #2003.
gitk python/pip_install/pip_repository.bzl

# Moved from here in #589; uses `--` because the file no longer exists.
gitk -- python/pip_install/extract_wheels/lib/bazel.py
```

Here's the entire history of the `pypi_*` tags:

| PR  | commit |
| :-- | :----- |
| bazel-contrib/rules_python#2003 | bazel-contrib/rules_python@04a803c286451f7ad782369b7c529a46e6ad5c9e |
| bazel-contrib/rules_python#1336 | bazel-contrib/rules_python@608ddb75057736f3f47095f5fe300f8a13a98bd0 |
| bazel-contrib/rules_python#953  | bazel-contrib/rules_python@70cce26432187a60b4e950118791385e6fb3c26f |
| bazel-contrib/rules_python#946  | bazel-contrib/rules_python@50ba3ed843b710259b9a4ca4634f4026a2294af2 |
| bazel-contrib/rules_python#937  | bazel-contrib/rules_python@72ac64a9966d3e2017393b9280a4d4575c538235 |
| bazel-contrib/rules_python#807  | bazel-contrib/rules_python@f0efec5cf8c0ae16483ee677a09ec70737a01bf5 |
| bazel-contrib/rules_python#743  | bazel-contrib/rules_python@4984423f72d289d4dd1db20b6b6b7637d61e5959 |
| bazel-contrib/rules_python#700  | bazel-contrib/rules_python@9b8ab1ea442064ee5ae5cafc1b66137281813c81 |
| bazel-contrib/rules_python#589  | bazel-contrib/rules_python@7740b22d0bae942af0797967f2617daa19834cb3 |
| bazel-contrib/rules_python#530  | bazel-contrib/rules_python@c303849892a2c716a2582172be43ba525feac23d |

## TODO

Frank P's original code was checking [File.owner] values to partition source
files based on their [Label.repo_name]. None of the examples currently do that,
but I'm thinking of developing an example sort of like:

```py
_THIS_REPO = Label("//:unused").repo_name

if file.owner.repo_name == _THIS_REPO:
    internal[file] = True
else:
    external[map_file_to_pypi_name(file)] = True
```

[Bazel's query language]: https://bazel.build/query/guide
[File.owner]: https://bazel.build/rules/lib/builtins/File#owner
[Label.repo_name]: https://bazel.build/rules/lib/builtins/Label.html#repo_name
[MODULE.bazel]: ./MODULE.bazel
[Module extensions: Repository names and visibility]: https://bazel.build/external/extension#repository_names_and_visibility
[Target]: https://bazel.build/rules/lib/builtins/Target
[blog]: https://blog.engflow.com/category/bzlmod/
[canonical repo name]: https://bazel.build/external/overview#canonical-repo-name
[genquery]: https://bazel.build/reference/be/general#genquery
[gitk]: https://git-scm.com/docs/gitk
[jq]: https://jqlang.org/
[json]: https://bazel.build/rules/lib/core/json
[pip_tags.bzl]: ./pip_tags.bzl
[provider]: https://bazel.build/extending/rules#providers
[py_library]: https://rules-python.readthedocs.io/en/latest/api/rules_python/python/private/py_library_rule.html#py_library
[py_wheel]: https://rules-python.readthedocs.io/en/latest/api/rules_python/python/packaging.html#py_wheel
[query.sh]: ./query.sh
[repository_ctx.read]: https://bazel.build/rules/lib/builtins/repository_ctx#read
[repository_rule]: https://bazel.build/external/repo
[rules_python]: https://github.com/bazel-contrib/rules_python
[rules_python_pypi_info.patch]: ./rules_python_pypi_info.patch
[single_version_override]: https://bazel.build/rules/lib/globals/module#single_version_override
[slack]: https://bazelbuild.slack.com/archives/C014RARENH0/p1743540276719369
[standard Bazel providers]: https://bazel.build/rules/lib/providers
[tags]: https://bazel.build/reference/be/common-definitions#common-attributes
[whl_library]: https://github.com/bazel-contrib/rules_python/blob/1.3.0/python/private/pypi/whl_library.bzl#L363-L366
