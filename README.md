# `rules_python` Pip name examples

Exploration of ways to retrieve PyPI metadata from repos generated by the
`pip.parse` module extension from [bazel-contrib/rules_python][rules_python].

Inspired by [a question in the #bzlmod channel of the Bazel Slack workspace from
Frank P on 2025-04-01][slack].

## Background

Frank P had the need to find the PyPI package to which a dependency's source
file belongs, to generate a `requirements` list for [py_wheel][]. He'd
previously used something like the following, which depends upon the [canonical
repo name][] of the repo generated via the `pip.parse` module extension tag:

```py
PIP_REPO_PREFIX = "rules_python++pip+<hub_name>_311_"

owner_name = file.owner.repo_name

if owner_name.startswith(PIP_REPO_PREFIX):
    pypi_name = owner_name.removeprefix(PIP_REPO_PREFIX)
```

He'd noted the following quote from [Module extensions: Repository names and
visibility][] (emphasis mine):

> Repos generated by extensions have canonical names in the form of
> `module_repo_canonical_name+extension_name+repo_name`. Note that
> __the canonical name format is not an API you should depend on â€”
> it's subject to change at any time.__

My stopgap suggestion was to search for the `"<hub_name>_311_"` marker instead
of the entire repo prefix:

```py
PIP_REPO_MARKER = "<hub_name>_311_"

owner_name = file.owner.repo_name

if PIP_REPO_MARKER in owner_name:
    _unused_prefix, pypi_name = owner_name.split(PIP_REPO_MARKER)
```

It may be less fragile than depending on the whole canonical repo name, but it's
not wonderful. I've been obsessed with canonical repo name issues, as evidenced
by my [EngFlow blog series on Bzlmod][blog], so I wanted to find another way.

I discovered the `pypi_name` and `pypi_version` tags that [whl_library][] adds
to [py_library][] targets for PyPI packages. bazel-contrib/rules_python#530
first introduced these tags to "[allow] tooling to use a bazel query to
reverse-engineer a requirements.txt from a transitive closure of a py_binary."

These seem like just the right source of truth for extracting the original PyPI
package names and versions. However, even though [the 'tags' attribute is common
to all rules][tags], there is no standard API to collect them from a [Target][].
They are not included in any [standard Bazel providers][].

## Experiments

The first two experiments use [Bazel's query language][] to find rules matching
the `pypi_name=.*` tag. These produce files that would have to be generated and
parsed somewhere in the build graph.

The last experiment adds a new [provider][] to `rules_python` to collect PyPI
names and versions directly from `py_library` targets.

### [query.sh][]

This script uses `bazel query` and [jq][] to filter the PyPI names from all the
targets in the repo. It's more an initial proof of concept than a practical
solution.

```sh
$ ./query.sh

Loading: 0 packages loaded
"pyfakefs"
"urllib3"
"zipp"
```

### `//:names.json`

`pip_names_query` from [pip_tags.bzl][] instantiates a [genquery][] to perform a
query similar to [query.sh][], but scoped to a specific target. It emits a full
JSON file, since [jq][] isn't included in any toolchains.

```sh
$ bazel build //:names.json

INFO: Analyzed target //:names.json (0 packages loaded, 1 target configured).
INFO: Found 1 target...
Target //:names.json up-to-date:
  bazel-bin/names.json
INFO: Elapsed time: 0.095s, Critical Path: 0.00s
INFO: 1 process: 1 action cache hit, 1 internal.
INFO: Build completed successfully, 1 total action

$ jq -C . < bazel-bin/names.json | less

{
  "type": "RULE",
  "rule": {
    "name": "@@rules_python++pip+pips_313_pyfakefs//:pkg",
    "ruleClass": "py_library",
    "location": "BUILD.bazel:5:20",
    "attribute": [
      # ...snip...
      {
        "name": "tags",
        "type": "STRING_LIST",
        "stringListValue": [
          "pypi_name=pyfakefs",
          "pypi_version=5.8.0"
        ],
        "explicitlySpecified": true,
        "nodep": false
      },
      # ...snip...
```

Such a target could perhaps be generated by a [repository_rule][], which another
repository rule could depend upon. This latter repository rule could use
[repository_ctx.read][] and the [json][] module to parse the result and generate
a BUILD target from it. This target could then return a [provider][] exposing the
PyPI name mapping.

### `//:lists`

`pip_and_srcs_lists` from [pip_tags.bzl][] depends on the `PypiInfo`
[provider][] from [rules_python_pypi_info.patch][]. The
[single_version_override][] in [MODULE.bazel][] applies this patch to
`rules_python`.

This implementation is arguably the most powerful and most correct way of
retrieving the name of a PyPI module. From the `PypiInfo` docstring:

> PyPI metadata for py_library targets and their dependencies.
>
> `pip.parse` generates repositories that contain `py_library` targets for
> external PyPI dependencies. These `py_library` targets contain `pypy_name=...`
> and `pypy_version=...` tags, which become the `name` and `version` properties
> of this provider.
>
> Direct and transitive dependencies of the current target that contain
> `PypiInfo` become members of this target's `PypiInfo.pypy_deps` depset.

Frank P's original code also checked [File.owner] values to partition source
files based on their [Label.repo_name]. `pip_and_srcs_lists` iterates over the
transitive sources from [PyInfo][] and compares their `file.owner.repo_name`
values match `_THIS_REPO`.

```sh
$ bazel build //:lists

INFO: Analyzed target //:lists (49 packages loaded, 3113 targets configured).
INFO: Found 1 target...
Target //:lists up-to-date:
  bazel-bin/pip-list.txt
  bazel-bin/srcs-list.txt
INFO: Elapsed time: 0.484s, Critical Path: 0.00s
INFO: 3 processes: 3 internal.
INFO: Build completed successfully, 3 total actions

$ cat bazel-bin/pip-list.txt

pyfakefs
urllib3
zipp

$ cat bazel-bin/srcs-list.txt

bar/__init__.py
bar/bar.py
baz/__init__.py
baz/baz.py
foo/__init__.py
foo/foo.py
```



## History of the `pypi_*` tags

I used [gitk][] in a local clone of [rules_python][] to search for a commit with
`changing lines matching:` set to `"pypi_name="`.

Here's the entire history of the `pypi_*` tags. The entries with parenthetical
notes are discovered by `gitk`, but the string doesn't show up in the diffs. I
used `git show -p <commit>` and then searched for `"pypi_name="` or the previous
file name to verify what had happened.

| PR  | commit | file |
| :-- | :----- | :--- |
| bazel-contrib/rules_python#2003 | [04a803c](https://github.com/bazel-contrib/rules_python/commit/04a803c286451f7ad782369b7c529a46e6ad5c9e) | `python/private/pypi/whl_library.bzl` |
| bazel-contrib/rules_python#1336 | [608ddb7](https://github.com/bazel-contrib/rules_python/commit/608ddb75057736f3f47095f5fe300f8a13a98bd0) | `python/pip_install/pip_repository.bzl` |
| bazel-contrib/rules_python#953  | [70cce26](https://github.com/bazel-contrib/rules_python/commit/70cce26432187a60b4e950118791385e6fb3c26f) | `python/pip_install/tools/wheel_installer/wheel_installer.py` (renamed file) |
| bazel-contrib/rules_python#946  | [50ba3ed](https://github.com/bazel-contrib/rules_python/commit/50ba3ed843b710259b9a4ca4634f4026a2294af2) | `python/pip_install/extract_wheels/wheel_installer.py` (moved to new file) |
| bazel-contrib/rules_python#937  | [72ac64a](https://github.com/bazel-contrib/rules_python/commit/72ac64a9966d3e2017393b9280a4d4575c538235) | `python/pip_install/tools/lib/bazel.py` |
| bazel-contrib/rules_python#743  | [4984423](https://github.com/bazel-contrib/rules_python/commit/4984423f72d289d4dd1db20b6b6b7637d61e5959) | `python/pip_install/extract_wheels/bazel.py` (renamed file) |
| bazel-contrib/rules_python#700  | [9b8ab1e](https://github.com/bazel-contrib/rules_python/commit/9b8ab1ea442064ee5ae5cafc1b66137281813c81) | `python/pip_install/extract_wheels/lib/bazel.py` |
| bazel-contrib/rules_python#589  | [7740b22](https://github.com/bazel-contrib/rules_python/commit/7740b22d0bae942af0797967f2617daa19834cb3) | `python/pip_install/extract_wheels/lib/bazel.py` |
| bazel-contrib/rules_python#530  | [c303849](https://github.com/bazel-contrib/rules_python/commit/c303849892a2c716a2582172be43ba525feac23d) | `python/pip_install/extract_wheels/lib/bazel.py` |

[Bazel's query language]: https://bazel.build/query/guide
[File.owner]: https://bazel.build/rules/lib/builtins/File#owner
[Label.repo_name]: https://bazel.build/rules/lib/builtins/Label.html#repo_name
[MODULE.bazel]: ./MODULE.bazel
[Module extensions: Repository names and visibility]: https://bazel.build/external/extension#repository_names_and_visibility
[PyInfo]: https://rules-python.readthedocs.io/en/latest/api/rules_python/python/defs.html#PyInfo.transitive_original_sources
[Target]: https://bazel.build/rules/lib/builtins/Target
[blog]: https://blog.engflow.com/category/bzlmod/
[canonical repo name]: https://bazel.build/external/overview#canonical-repo-name
[genquery]: https://bazel.build/reference/be/general#genquery
[gitk]: https://git-scm.com/docs/gitk
[jq]: https://jqlang.org/
[json]: https://bazel.build/rules/lib/core/json
[pip_tags.bzl]: ./pip_tags.bzl
[provider]: https://bazel.build/extending/rules#providers
[py_library]: https://rules-python.readthedocs.io/en/latest/api/rules_python/python/private/py_library_rule.html#py_library
[py_wheel]: https://rules-python.readthedocs.io/en/latest/api/rules_python/python/packaging.html#py_wheel
[query.sh]: ./query.sh
[repository_ctx.read]: https://bazel.build/rules/lib/builtins/repository_ctx#read
[repository_rule]: https://bazel.build/external/repo
[rules_python]: https://github.com/bazel-contrib/rules_python
[rules_python_pypi_info.patch]: ./rules_python_pypi_info.patch
[single_version_override]: https://bazel.build/rules/lib/globals/module#single_version_override
[slack]: https://bazelbuild.slack.com/archives/C014RARENH0/p1743540276719369
[standard Bazel providers]: https://bazel.build/rules/lib/providers
[tags]: https://bazel.build/reference/be/common-definitions#common-attributes
[whl_library]: https://github.com/bazel-contrib/rules_python/blob/1.3.0/python/private/pypi/whl_library.bzl#L363-L366
